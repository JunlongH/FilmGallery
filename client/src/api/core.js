/**
 * API Client - Core utilities and configuration
 * 
 * Provides base URL, fetch helpers, and common upload functions.
 */

// Prefer 127.0.0.1 over localhost to avoid potential IPv6 issues in packaged builds
// In Electron production, use the API_BASE exposed by preload, otherwise fallback to localhost for dev
export const API_BASE = (typeof window !== 'undefined' && window.__electron?.API_BASE) 
  ? window.__electron.API_BASE 
  : (process.env.REACT_APP_API_BASE || 'http://127.0.0.1:4000');

/**
 * Get current API_BASE (may change in hybrid mode after initial load)
 * Use this for runtime requests to ensure we use the latest configured server
 */
export function getApiBase() {
  if (typeof window !== 'undefined' && window.__electron?.API_BASE) {
    return window.__electron.API_BASE;
  }
  return API_BASE;
}

// ============================================================================
// Global Image Cache Buster
// ============================================================================

/**
 * Global cache-buster version.
 * When incremented, all image URLs generated by buildUploadUrl will include
 * a new `_cb=` query parameter, forcing the browser to bypass its HTTP cache
 * (even for resources marked immutable/max-age=1y).
 *
 * Persisted to sessionStorage so it survives soft navigations but resets on
 * new sessions (when the app/window restarts the server may have changed files).
 */
let _cacheBusterVersion = (() => {
  try {
    return parseInt(sessionStorage.getItem('__fg_cb') || '0', 10) || 0;
  } catch { return 0; }
})();

/**
 * Increment the global cache-buster, causing every subsequent buildUploadUrl
 * call to produce a new URL that the browser has never cached.
 * @returns {number} The new version
 */
export function bustImageCache() {
  _cacheBusterVersion = Date.now();
  try { sessionStorage.setItem('__fg_cb', String(_cacheBusterVersion)); } catch {}
  // Dispatch a custom event so React components can re-render with new URLs
  window.dispatchEvent(new CustomEvent('fg-cache-bust', { detail: _cacheBusterVersion }));
  return _cacheBusterVersion;
}

/**
 * Get CacheBusterVersion (0 = no busting).
 */
export function getCacheBusterVersion() {
  return _cacheBusterVersion;
}

/**
 * Build an absolute URL for an uploaded file value stored in the DB.
 * Uses dynamic API_BASE for hybrid mode support.
 * Automatically appends a cache-buster query param when active.
 */
export function buildUploadUrl(pathOrUrl) {
  const apiBase = getApiBase();
  if (!pathOrUrl) return null;
  let url;
  // already absolute URL
  if (pathOrUrl.startsWith('http://') || pathOrUrl.startsWith('https://')) {
    url = pathOrUrl;
  }
  // leading slash -> relative to API_BASE
  else if (pathOrUrl.startsWith('/')) {
    url = `${apiBase}${pathOrUrl}`;
  }
  // contains 'uploads' somewhere (e.g. Windows full path like D:\...\uploads\rolls\...)
  else {
    const lower = pathOrUrl.toLowerCase();
    const idx = lower.indexOf('uploads');
    if (idx !== -1) {
      // extract from 'uploads' onward and normalize slashes
      const sub = pathOrUrl.slice(idx).replace(/\\/g, '/').replace(/^\/+/, '');
      url = `${apiBase}/${sub}`;
    }
    // Windows path fallback - use basename
    else if (pathOrUrl.indexOf('\\') !== -1 || /^([a-zA-Z]:\\)/.test(pathOrUrl)) {
      const parts = pathOrUrl.split(/[/\\]+/);
      const base = parts[parts.length - 1];
      url = `${apiBase}/uploads/${base}`;
    }
    // default: assume value is relative inside uploads (e.g. 'rolls/..')
    else {
      url = `${apiBase}/uploads/${pathOrUrl.replace(/^\/+/, '')}`;
    }
  }

  // Append global cache-buster if active
  if (_cacheBusterVersion > 0) {
    const sep = url.includes('?') ? '&' : '?';
    url += `${sep}_cb=${_cacheBusterVersion}`;
  }
  return url;
}

/**
 * Generic JSON fetch wrapper
 * Uses dynamic API_BASE to support runtime server switching
 */
export async function jsonFetch(url, opts = {}) {
  const apiBase = getApiBase();
  const r = await fetch(`${apiBase}${url}`, opts);
  const text = await r.text();
  try { return JSON.parse(text); } catch { return text; }
}

/**
 * POST JSON data
 */
export async function postJson(url, data) {
  return jsonFetch(url, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(data)
  });
}

/**
 * PUT JSON data
 */
export async function putJson(url, data) {
  return jsonFetch(url, {
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(data)
  });
}

/**
 * DELETE request
 */
export async function deleteRequest(url) {
  return jsonFetch(url, { method: 'DELETE' });
}

/**
 * Upload file with progress support using XMLHttpRequest
 * @param {string} url - API endpoint path
 * @param {FormData} formData - Form data to upload
 * @param {function} onProgress - Progress callback (0-100)
 * @param {object} options - Optional settings
 * @param {number} options.timeout - Timeout in ms (default: 5 minutes)
 */
export function uploadWithProgress(url, formData, onProgress, options = {}) {
  const { timeout = 5 * 60 * 1000 } = options; // 5 minutes default
  
  // Get current API_BASE (may have changed since module load in hybrid mode)
  const apiBase = (typeof window !== 'undefined' && window.__electron?.API_BASE) 
    ? window.__electron.API_BASE 
    : API_BASE;
  
  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();
    xhr.open('POST', `${apiBase}${url}`);
    xhr.timeout = timeout;
    
    xhr.onload = () => {
      if (xhr.status >= 200 && xhr.status < 300) {
        try { resolve(JSON.parse(xhr.responseText)); } 
        catch(e) { resolve(xhr.responseText); }
      } else {
        const errorMsg = xhr.statusText || `HTTP ${xhr.status}`;
        console.error('[Upload] Failed:', xhr.status, xhr.responseText);
        reject(new Error(errorMsg));
      }
    };
    
    xhr.onerror = () => {
      console.error('[Upload] Network error - API_BASE:', apiBase, 'URL:', url);
      reject(new Error('Network error: Failed to connect to server'));
    };
    
    xhr.ontimeout = () => {
      console.error('[Upload] Timeout - API_BASE:', apiBase, 'URL:', url);
      reject(new Error('Upload timeout: Request took too long'));
    };
    
    if (xhr.upload && onProgress) {
      xhr.upload.onprogress = (ev) => {
        if (ev.lengthComputable) {
          onProgress(Math.round(ev.loaded / ev.total * 100));
        }
      };
    }
    xhr.send(formData);
  });
}

/**
 * Upload files to temporary storage for preview
 */
export async function uploadTmpFiles(files, onProgress) {
  const fd = new FormData();
  files.forEach(f => fd.append('files', f));
  return uploadWithProgress('/api/uploads', fd, onProgress);
}

/**
 * Build query string from params object
 * Filters out React Query context properties that may be passed when used as queryFn
 */
export function buildQueryString(params) {
  if (!params || typeof params !== 'object') return '';
  
  // React Query context properties to filter out
  const REACT_QUERY_PROPS = new Set(['client', 'queryKey', 'signal', 'meta', 'pageParam', 'direction']);
  
  const qs = new URLSearchParams();
  for (const [key, value] of Object.entries(params)) {
    // Skip React Query internal properties
    if (REACT_QUERY_PROPS.has(key)) continue;
    // Skip undefined/null/empty values
    if (value !== undefined && value !== null && value !== '') {
      qs.append(key, value);
    }
  }
  const str = qs.toString();
  return str ? `?${str}` : '';
}
